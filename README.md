### 跳跃游戏全系列
[1 跳跃游戏I](jumpGame/Jump.java) 
- https://leetcode-cn.com/problems/jump-game/


[2 跳跃游戏II](jumpGame/Jump.java) 
- https://leetcode-cn.com/problems/jump-game-ii/

[3 青蛙过河（跳石子过河）](jumpGame/FrogCanCross.java) 
- https://leetcode-cn.com/problems/frog-jump/
```
1. map反向索引表， <stones[i], i>， 可以快速定位 1. 跳到的位置是否存在 2.存在的话，O(1)返回下标
2. 注意题目说明了， 不回跳 -> 跳跃步数 >= 0
3. 再次根据题目， 跳跃距离的范围 是 [0, N - 1] -> 在 i位置的 lastDistance最大为 i
4. 对于时间测量而言，我测了一下 记忆化搜索不同 cache结构的时间：
    - 多个参数使用String.valueOf连起来 HashMap<String, Boolean> -> 最慢的
    - HashMap<Integer, HashMap<Integer, Boolean>> -> 快 2/3
    - 如果可以使用数组当然好，但是本题需要分析出来 lastDist范围是固定的这件事情，最快 —— 36ms
5. 由于 测出有一条路径能够 最后一个石子 就够了，所以可以进行剪枝
- 事实证明，虽然多了几行代码，但是常数时间快了一倍
```


### 股票买卖全系列
关键点： 从左往右尝试模型 -> 考虑 最后一个位置是否参与 从而划分出两个大类！！！

- [股票I](sellstock/StockCollection.java):
- https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
- 只进行一次交易

- [股票II](sellstock/StockCollection.java):
- https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
- 任意次数
- （首选）方法一： 波峰波谷图，求每一个波峰的高度  -> ans += Math.max(prices[i] - prices[i - 1], 0)
- 方法二： 动态规划 + 斜率优化

- [股票III](sellstock/StockCollection.java):
- https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
- !! 给定次数，两次.  只允许做不超过两次的交易
- 可以不使用动态规划做
- 怎么做呢 - O（N） + O（1）
- （首选）最优解， 很强的一个贪心：假设每一个位置上的数字 是第二次卖出的时刻， 遍历一遍，求最大值
  - 需要设置几个变量
  - 假设每一个位置的前面已经有过一次最好的max并且计算了max-[后续中的最小] ，那么由于我们计算的是当前位置为第二次卖出的情况
  - 所以统计每次的答案即可
  - 具体一点，对于每一个位置，首先计算 
      【1】当前作为第二次卖出的价格 
      【2】到目前为止，最好的第一次卖出的价格 
      【3】到目前为止，最好的卖出 + 最好的买入的价格（也就是 第一次卖出-该卖出点后面的最低买入点 的最佳值）
  - 贪心在 如果后面更新了 onceMax（第一次交易的最大值），那么后续如果出现了能让之前的onceMax-prices[i]变大的数字，那么新的curMax-prices[i]一定是当前最优解
    所以，在最关键的变量 onceMinusBuyMax中，只需要查看是否 当前位置作为买入点，是否比之前的onceMinusBuyMax就好了
- [股票IV](sellstock/StockCollection.java):
- https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/
- 固定K次
- 动态规划 + 斜率优化
- E.G. 对于 dp[3][4]， 考虑两个大情况 3位置不参与(dp[2][4]) 和 3位置参与 的情况， 然后在3位置参与情况下细分

- [股票V](sellstock/StockCollection.java):
- https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
- 与 II 问题一样是无限次的交易，只是添加了 coolDown de 要求
- cooldown： cool down 问题， 卖出时刻之后 必须等待一个时刻，才可以继续开始买卖， 无限次交易
- buy[22] 表示 在 0-22范围内无限次交易下所获得的最优收入 - 综合考虑后的优良买入时机对应价格，   --> 综合起来之后的【最优】 就是 buy[22]
- sell[i] 表示 0-i 范围内无限次交易，最后一次是 卖动作 所能获得的最大收益
- [股票VI](sellstock/StockCollection.java):    
- https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/
- 带手续费
- 与问题V相同，方法也相同
- buy[i]0-i范围上，最后一个动作必须是买，的整体最优     sell[i]最后一个动作是卖的最大利润


### 数据结构设计题
[1] 哈希表的设计，实现 setAll() 方法，要求O(1)时间

[2] （重要）已知一个消息流会不断地吐出整数1~N，但不一定按照顺序依次吐出，如果上次打印的序号为i， 那么当i+1出现时
请打印i+1及其之后接收过的并且连续的所有数，直到1~N全部接收并打印完，请设计这种接收并打印的结构
- 两张哈希表， 一张连续区间头表， 一张连续区间尾表
    - 哈希表内部结构 头表 <5， 1>  =》 以5开头长度为1


[3 LRU](dataStructureDesign/LRU.java) 
- https://leetcode-cn.com/problems/lru-cache/
- 具体错误点看代码，注意细节 -> 什么时候需要更新doubleLinkedList (get方法和put方法中 都需要考虑)

[4 LFU] 

[5] Top K 字符串问题【Hard】
```
Top K Frequent Words II
Implement three methods for Topk Class:
TopK(k). The constructor.
add(word). Add a new word.
topk(). Get the current top k frequent words.
LintCode题目：https://www.lintcode.com/problem/550/
```
- 加强堆 -> 多一张反向索引表 (key -> index)


### 最长递增子序列模型 - 系列 
```
LIS问题，好好理解。 
order < a 的最右 位置为pre， 
【1】将a放在 （pre + 1）位置上，即 (pre + 1) + 1 就是以a结尾的LIS。
【2】将a放在 （pre + 1）位置上，此时整个order数组中，有效的最长长度 就是 0-a下标 范围内的 LIS。
```

[1 最长递增子序列](longestIncreasingSubsequence/LongestIncreasingSubseq.java) 
- https://leetcode-cn.com/problems/longest-increasing-subsequence/
- O(N logN)  -> 新建数组（存储当前的最长子序列，并将每一个位置更新为最小的元素） + 二分法


[2 俄罗斯套娃问题](longestIncreasingSubsequence/maxEnvelopes.java) 
- https://leetcode-cn.com/problems/russian-doll-envelopes/
- 使用 最长严格递增子序列 模型
    - 首选对数组排序 -> 实现 一维顺序，二维逆序。 此时，如果出现 后边h比前边的h大，那么w也一定大
    - 直接对 数组的第二维元素进行 最长递增子序列模型 往上套就可以 （创建数组记录最长递增子序列 —> 遍历 -> 二分查找）
    - 排序 O（N logN）, 最长递增子序列模型 O（N logN）

[3 (easy题，变种题)最长连续递增子序列](longestIncreasingSubsequence/FindLengthOfLCIS.java) 
- https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/

### 子数组达到规定累加和 的 最长数组长度 系列
[1 （一连问题）非负整数达到规定累加和] 
- 双指针滑动窗口

[2 （二连问题）整数达到规定累加和] 
- 前缀和数组 + HashMap

[3 （三连问题）整数达到规定累加和<=M 的 最长子数组长度] 
- dp， 创建两个数组 




### 二叉树基础
[1 二叉树非递归三序遍历](BTBasic/PreInPostTraversal.java) 
- pre: https://leetcode-cn.com/problems/binary-tree-preorder-traversal/
  - 一个栈： 头左右往里放， 头弹出时，看做头结点，处理 + 向栈中放入右，左孩子

- post: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/
  - 后序遍历 基于 先序遍历解法
  - 不同之处只是 多一个 Stack<Integer> help 用来存放 【头右左】 顺序的结果。 然后只需要依次弹出就可以得到 【左右头】的结果了
    - 栈用于逆序结果

- in: https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
  - 一开始，令 cur = root
  - while (!stack.isEmpty() || cur != null)
    - 只要栈不为空或者cur指向非空，那么就可以继续执行
        - 分两种情况：
        - 【1】 cur != null， 说明当前节点不为空，那么 【左头右】的原则，将当前 cur 入栈，继续向左孩子寻找最左节点
        - 【2】 cur == null， 当前来到空节点，说明 上一个节点存储的就是 （当前的）最左节点，将栈顶弹出，然后处理该元素（这就是对应inorder的元素），然后 cur = cur.right， 因为【左中右】了

[2 二叉树的层序遍历（带分层）](BTBasic/LevelOrder.java) 
- https://leetcode-cn.com/problems/binary-tree-level-order-traversal/
- 带分层方法，分层方法非常简单
    - 首先记录当前 int size = queue.size()
    - 内部 while (size-- > 0) ， 执行 【一个层数中次数】的 BFS入队出队
    - 在 内部 while 结束后，说明该层已经遍历完毕，queue存放下一层的节点。此时可以对之前处理的结果进行 【针对每一层的处理】。  

[3 二叉树的序列化和反序列化]
```
序列化是将一个数据结构或者对象转换为连续的比特位的操作，
进而可以将转换后的数据存储在一个文件或者内存中，
同时也可以通过网络传输到另一个计算机环境，
采取相反方式重构得到原数据。
```
- 对于二叉树的序列化反序列化而言， 层序遍历，先序遍历，后序遍历都可以得到唯一的 序列化结果（序列化结果中包含null，指示null节点的位置）。 但是中序遍历会存在 不同结构对应相同结果，所以不能使用中序遍历实现序列化。
- 使用【队列】
### 二叉树递归套路
[1 BST与双向链表](BTRecursive/BSTToDoublyList.java) 
```
给定一棵搜索二叉树头节点，转化成首尾相接的有序双向链表（节点都有两个方向的指针）
```
- https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/
- 二叉树递归套路！！
- Info 包含 头指针 + 尾指针
- 错误点1】少连了 cur -> left.tail。 summary: 双向链表的连接和删除一定要特别谨慎。两个节点都要进行操作。  不像单链表只需要操作一个节点就可以。


### TopK



### 排序
- 排序算法链接 -> https://leetcode-cn.com/problems/sort-an-array/

[1 快速排序](sort/QuickSort.java) 

[2 归并排序](sort/MergeSort.java)

[3 桶排序](sort/HeapSort.java)
- 只需要使用 【堆的向下调整】就可以



### 链表类经典题目
[1 反转链表](linkedlist/ReverseList.java) 递归 + 非递归
- https://leetcode-cn.com/problems/reverse-linked-list/


[2] 链表相交问题，寻找相交节点
- [2.1 寻找一个链表的入环节点](linkedlist/DetectCircle.java)
  - https://leetcode-cn.com/problems/linked-list-cycle-ii/
  - 注意： 错过几遍，记得重做
  - 解法： 快慢指针 -> 慢指针, 快指针
    - 【1】快指针有尽头，说明无环，返回null; 
    - 【2】只要有环，快慢指针必会相遇 -> 接着慢指针留在相遇点，快指针初始化为从head开始步长为1，快慢指针同时往前走，再次相遇点就是入环节点
    - 【错误点！】 **slow , fast 起始位置都要为 head！！！**，然后再开始快慢指针的
    
- [2.2 两个无环链表的相交节点](linkedlist/GetIntersectionNode.java)
  - https://leetcode-cn.com/problems/intersection-of-two-linked-lists/
  - 解法：
        - 首先获取 headA 与 headB 最后一个节点。 并且在过程中，记录两条链表的长度
            - 如果最后一个节点相同，那么说明有相交； 如果最后一个节点不相同，那么就返回Null
        - 重定位cur1, cur2 对应长短链表， 然后 cur1 先走 n步（多出来的n个节点直接跳过，来到剩余长度相同的位置）
        - cur1, cur2一起向前走，while(cur1 != cur2) ==》 退出时，就是相交界点了

- [2.3 两个有环链表的相交节点] 

[3] 删除链表的倒数第N个节点 （跳的是 次数）
- https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
- 快慢指针，快指针先走，慢指针后走。 快指针到头了，慢指针删除节点就可以 -> 解法只用 【一趟扫描】
    - 所以要注意一个点，慢指针最终指向的不应该是 【待删除的点】，应该是 【待删除节点】的前一个节点（因为单链表）
    - 所以需要先确定 fast的结束位置， 然后计算好 到底 fast 先走多少步 （举例子应该很快就能有答案了）
    - 针对上一点，还要注意 删除节点是头结点的情况（看来注意的点还挺多的）
    - 刚想了一下，因为n<=size（当然这个没所谓），一次遍历就可以解出来的
        - 根据前提版本，以cur.next==null为结束标志，倒数第K个节点的话，fast先跳 （k-1）个节点。
        - 所以先让 fast 跳 (k - 1)，然后查看此时是否fast是最后一个节点，如果是的话， 就是【删除头结点的情况，直接处理后返回新的头结点】
        - 如果fast并不是最后一个节点，此时只需要再让fast = fast.next； 此时slow就对应着 【删除节点的前一个节点的初始slow了】，然后slow,fast走到底，那么就可以执行删除操作
        - 这个解法中，如果没有说明n<=size，那么在一开始往前走的过程中，加入条件判断就可以了。
- 这道题的前提版本： “找倒数第N个节点”
    - https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
    - fast while(fast.next != null)，fast先跳 n-1次 
  
- 更新(dummy法很好用)： 使用dummy 节点，因为题目说明了 n<=size， 加入了 dummy之后，n < size。 非常快捷且简单的做法
  - ！！！设置dummy节点可以 -> 不需要额外处理 【删除节点就是开头节点的问题】
  - fast 先跳 N 次

### 字符串相关问题

[1] 最长不重复字串
    - hashMap + 一维dp



### 链表排序问题

[1 链表的插入排序] 

[2 链表的快速排序] 


### 搜索旋转排序树组
- 最差情况下就是O（N），无法避免
  - 1 2 2 2 2 2 2， 1可能会出现在任何位置，但是我们要寻找1. 此时就有可能要 O（N）



### 回溯经典
[1] N皇后问题I

[2] N皇后问题II


### DP经典题
- 对于很多dp题而言，分析关键就是 对于 dp[i]而言， i位置 【参与】 还是 【不参与】，这样的思路来指示如何分析状态转移
[1] 最长公共子序列　-> 样本对应模型
- 【重点】dp[i][j] 含义 -> 表示 str1的[0, i]范围 与 str2的[0, j]范围 内的 最长公共子序列 个数
- 注意，第一题和第二题，虽然对应不同的 尝试模型，但是在做出 空间压缩 的解法上具有相同方法，多多加固
    - 先快速写出 二维dp表 版本
    - 然后，将 对每行的 操作 写在同一个 for循环里面
    - 然后就很套路， for(j)外面 加个tmp，  然后for(j)里面用ans先记住答案，然后赋值之前tmp记住之前的值，然后dp[i][j]=ans
    - 这样，tmp就记录了当前被覆盖的值 (LeftUp, LeftDown... 都可以)
    - 最后， dp[i][j]  -> 删掉"[i]"就可以 -> dp[j]

[2] 最长回文子序列 -> 范围尝试模型 [i, j]
- 比较特别，二维dp
- 【难点，重点】 dp[i][j]含义特别， 表示 [i, j] 范围内的 最长回文子序列 个数。
    - 并且，这种定义下，要注意一个默认条件就是 【i <= j】的区域才有效。也就是说 有一半区域是无效的（i>j区域无效，不求）
    - 会发现， base case ，最初要填的位置 从 【底边】 变成了-> 【45度线】（并且也只有45度可以直接求）

[3 正则表达式匹配] 这个不说我都不知道可以使用DP。
- https://leetcode-cn.com/problems/regular-expression-matching/
- 两个字符串匹配 -> 样本对应模型
- dp[i][j] 含义  -> str[i...]（str从i出发到结尾的所有） 与 exp[j...] 能否配出来
- 但是比较难，所以先写的时候 最好使用 暴力递归先写出来
    - 傻缓存法，使用int[], 因为必须有一个状态描述算没算过。
### KMP 算法

### Manacher
[1 最长回文子串](manacher/LongestPalindrome.java)
- https://leetcode-cn.com/problems/longest-palindromic-substring/
- 一定要通过在 原字符之间 添加 虚字符，形成新的处理串。
  - 不然的话，以每一个点往左右两边扩的时候， 奇数的回文串可以扩出来，但是偶数的回文串无法扩出来。只有添加了 【虚字符（比如“#”）】后，遍历每一个元素的位置对应的 回文串个数/2， 最大值即为最终结果。
- （1）小问题，不使用“#”进行填充，而选用字符串中已经有的字符，会不会算错？
    - 答： 不会。因为 不会有任意一个时刻，使得 【虚字符】 与 【实字符】 比对的情况。所以 【虚的】 是什么字符 都可以。
- 核心点： 【精辟一点，记住核心点记牢Manacher】
  - 记录 扩到最右的回文右边界R, 以及对应的 中心点C
  - 当到达每一个当前位置i时，通过下标变换找到关于当前 C 的对称点 i'， 此时基于两种大情况推断出当前位置的回文半径
    - 【1】i 在 R 外 -> 暴力扩
    - 【2】i 在 R 内
      - 使用 pArr[i'] 表示 i'的回文半径
      - 【1】 if (pArr[i'] 在 C-R 内)，那么 pArr[i] = pArr[i']
      - 【2】 if (pArr[i'] 在 C-R 外)， 那么 pArr[i] = R - i + 1 (也就是 i 到 R 的距离)
      - 【3】 if (pArr[i] 落在了 C-R 上面)， 那么此时要 硬核 向两边扩充以硬核计算当前位置的pArr[i]
        - 并且此时要注意，在向右边扩充的时候，更新R和C；
      - 还要注意一点就是， 如果此时 i > R, 那么 pArr[i] 初始化为1. 然后向两边扩充
- 处理串中的 【回文半径 - 1】 就是 原字符串的 真实回文子串的长度
  - 处理串中的 i 位置的回文子串的长度L 对应到 原串就是 L / 2  (奇偶通用)
- 处理串中 点i 的位置 对应处理半径 pArr[i] ==> 对应到 原始串 就是 i/2 位置的 【回文子串长度】 pArr[i] - 1
- 时间复杂度分析， 分析 R 的上升变化：
  - 对于每一个位置 i, 他一定会有一次失败（扩失败或者扩到边界） ==》 一共失败N次（一共N个位置，每个位置失败1次）
  - 扩成功的话，
    - 讨论i在R外暴力扩的情况，此时R会更新，R只会上升
    - 【2】【1】 O（1）
    - 【2】【2】O（1）
    - 【2】【2】， 失败一次，成功依然推高R，也就是说 -> R的范围只会从0到N
    - 所以， 只要扩成功， R 只会增大，R最大幅度就是N，所以整个过程 O（N）

### 单调栈


### 滑动窗口内最大值最小值更新结构


### 线段树


### indexTree


### AC自动机


### 图


### 反转整数系列
[1 字符串转整数](reverseIntegerSeries/MyAtoi.java)：
  - 逻辑分清晰
  - 使用 负数承接数字， 最后看是否转成正数
  - 使用了两个 标志位 — isNum（当前是否是检测数字中） + isPositive(符号位记录)
  - 返回时，注意分情况讨论 溢出时 的问题

[2 整数反转]()


###
[1] 盛水的容器
- 不严格求每一个位置能够准确算出来的答案，它只关心有没有能够推高答案的可能性。 

### 二分法
[1] 寻找两个有序数组的中位数 - 【算法原型】
- 先给两小问
    - （1）给定两个等长的有序数组，整体求第五个  -> O（logN）   - 最关键的算法原型，其他方法 通过 【手动淘汰掉一个数字（额外检查）】来实现调用该算法原型的条件
    - （2）两个不等长但是 都有序的数组，整体求第K小的数字  -> O（log min{M, N}）
- 最优解 O(log min{M, N})



### 剪枝
- 剪枝就是 递归参数设计能力
  - 尽可能让分支不需要在最后一步验证，中间过程尽可能保证对。从而就能够减少时间复杂度


### 高频题随记
[36 有效的数独]
  - 只需要想清楚如何不重复就可以了
  - 建立三个 boolean[] 行，列，桶

[38 外观数列]: 就是一道 coding 题
  - 就是没有什么规律，从第一项开始解，算到第N项

[41. 缺失的第一个正数] (hard)
  - 字节问的是 >K 的情况下 缺少哪一个正整数， 只需要 将arr[]中的每个数字 都减去k ， 就转化成了该题！！！
  - 核心： 确定垃圾区和有效区， 垃圾区R同时对应期望的最好结果

[42. 接雨水]
- 只考虑 i位置 上方有多少水， 每个位置累加最终搞定
- 得到一个结论： cap(i) = min{[0, i - 1]的最大值,  [n + 1, arr.length - 1]的最大值} - height[i]。 这就是最终的高度
  - 特别考虑 当 结果值<0时，cap = 0。  反之，维持原值
- 初级解法： 怎样创建 i左侧最大值，右侧最大值O（1）获取呢？ 辅助数组
  - 建立两个辅助数组，分别遍历数组， 求得 在i位置，左侧最大值（A数组） + 右侧最大值（B数组）
- 最优解！
  - [0] [N - 1] 不用算，因为肯定两边是谷底，所以不乘水
  - L , R 从首尾开始的 双指针
  - 哪一侧的max小 LR谁结算，谁移动 （两侧记录max） （很像 盛水容器的那个双指针）


[49 字母异位词分组]
  - 【1】遍历每一个string， 排序，放到哈希表里去。 最后去除哈希表中的 values(List<>)
  - 【2】还是HashMap， 但是是将 字符串作为key值，寻找string相同的 异位词分组，适用于 =》 字母种类少（比如说，全是小写）。 可以使用词频统计，每个word， 生成字符串 =》 11_2_5

[69 x的平方根] （向下取整）只保留整数
- 二分法
- 每次检测 mid 的平方是 大于还是小于 target
- 然后调整 L ， R

[69 加题] 一个数double，开根号，再给你传一个K，表示保留小数点后几位，让你返回结果。
- 先计算出 整数部分（就按照上述方法）
- 假设整数部分是3， K=4，N=10， 那么结果必定在 [3.0000, 3.9999]之间
  - 对小数点后面的数字 再进行二分 （但是要注意转化， 比如 mid = 0.200, 那么此时测试 (3.200)^2 <= 10 ?）
  
[73 矩阵置零]
- 边遍历边改是不行的
- 初级方法， 额外空间复杂度O（M, + N）： 做一张行表boolean[]记录哪一行要变0，同样一张列表记录哪一列要变0，最后收集完成之后，遍历原数组更改值就可以
- O（1）两个变量： 利用原始数组的第0行和第0列 替代原始boolean[]的表
  - 一开始记录的时候，不遍历 第一行和第一列
  - 比如 arr[2][3] ==> 将 arr[2][0]  arr[0][3]置0 （然而这个方法必须 保证第0行第0列 没有0 才可以）
  - 所以怎么办呢， 提前记录 第0行第0列 有没有0 -> 行列需不需要变成0 （使用两个boolean变量）
  - 从而在 [1][1] -> [末尾]时，只用 第0列第0行 记录对应行列是否要变0
- 进一步 O(1) 只用一个boolean变量：
  - 利用了 [0][0] 位置记录 行是否为0的情况
  
[！！！重要DFS技巧 - 74 单词搜索] 【DFS不走走过的路径技巧】
- 【重要】 DFS ， 但是使用了 【改变现场+恢复现场】 的 方式 来 实现 DFS四个方向遍历 【但是不走回头路】 的技巧。
  - 首先将 当前走过的位置记录下来(char tmp = board[i][j])
  - 然后将 board[i][j] = 0 （因为board是char[][]， 所以 char = 0, 就是 ASCII为0的值，也就是空字符）， 从而在遍历时，遇上了会返回false
  - 然后开始递归
  - 递归返回后，恢复现场 -> board[i][j] = tmp
  - 正常返回值
  

[124 二叉树中的最大路径和]
- 【1】二叉树任意两点间的最大路径和 O（N） 二叉树的后序遍历 -> 二叉树的递归套路
- 【2】把最大路径和的沿途路径打印出来
  - 不仅让你汇报最大路径和是多少，并且让你 告诉我 首尾两端节点是谁
  - 再根据 他俩的最低公共祖先去生成整条路径
  
[125] 验证回文串
- 方法： 两端双指针
- 怎么比较不区分大小写的字母是否相等
  - a 与 A 相差 32  (a大97， A小65)
  - equal => c1 == c2 || Math.max(c1, c2) - Math.min(c1, c2) == 32 ?
  

[130 被围绕的区域]
- 解法： 从边界开始感染
- 基于感染的dfs模型
- （上下左右四个）边界为“O”的 感染，将其变成“F”。 然后剩余部分中 不是“F”的部分，遍历matrix全部变为“X”就可以了。 

[139 单词拆分I] 
- 从左往右的尝试模型
- 优化 -> 前缀树 =》 使用前缀树加速枚举（只需要在前缀树上尝试一个节点长度）（而不需要遍历数组），就知道存不存在该单词了）
- f(i) =》 从 i 出发到最后位置 是否满足条件
- 那用Set不可以吗？ 可以，但是不如前缀树的优化

[140 单词拆分II]
- 【知识点】根据动态规划表生成路径
- DFS + 回溯

[148 排序链表]
- （1）如果给定一个数组，要 时间复杂度为O（N logN）,额外空间复杂度O（1）  ==》 堆排序
- 但是，对于链表，不可行。为什么呢？ 数组的堆排序，是有固定位置依赖的，然而链表没有位置。
- 所有用什么呢？ 归并排序 （对于链表来说，归并排序 合并有序链表 不需要额外空间 =》 链表merge不需要额外空间）
- 要实现 非递归版本的 mergeSort
  - 步长 1 -> 2 -> 4 -> 8
  - 控制步长的过程，使用while
  
[150 逆波兰式]
- 压栈 出栈
- 遇到数字就压栈，遇到操作符就弹出两个数字进行计算，将结果再压回去


[172] 阶乘后的0
- 2的数量 > 5的数量 （任何一个5一定能够找到一个2）
- （第一轮）每5个一组有一个5， （第二轮）每25个一组一个5（这是多出来的5） （第三轮）每125个一组多出一个5， ... 直到 n为0

[189] 轮转数组
- 技巧性很强
- O（1）额外空间复杂度 -> **总共三步: 左侧逆序，右侧逆序，最后整体逆序** -> 原地完成旋转

[202 快乐数]
- 简单做法： set， 每一个中间过程数字都加入 set， 如果 当前数字已经在set中出现了，那么说明出现了环，那就永远不可能有1了
- 有一个结论： （怎么知道的呢？ 暴力法打表发现的）
    - 如果是快乐数的话，最终一定会跑到1
    - 如果不是快乐数的话，最终一定会遇到4（然后循环）
  
[213 打家劫舍]
- 第一小问：不能够取相邻数的情况下，子序列的累加和最大是多少？
  - 一维dp
  - dp[i] 代表 arr[0..i]范围上，随意选择，但是，任何两数不能相邻。得到的最大累加和是多少？
  - 可以只用有限几个变量滚动求解
- 第二小问： 线性数组变成首尾相连的环了
  - max { [0, N - 2], [1, N -1]}
  
[279 完全平方数]
- 四平方和定理：
  - 任何一个自然数，你拆成平方和的项不会超过四项
  

[287 寻找重复数] （高频）
- 时间复杂度 O(N)， 额外空间复杂度 O(1)
- 快慢指针
- 解法就是： 寻找链表的入环节点

[295 数据流的中位数] (hard)
- 解法： 大根堆 + 小根堆
  - 如果当前数 <= 大根堆的堆顶，入大根堆
  - 如果当前数 > 大根堆的堆顶，进入小根堆
  - 检查大小，如果 大根堆跟小根堆大小， 差值到达2， size大的堆顶弹出进入另一个堆
  - 这样做会造成一个奇妙的现象： 所有数中较小的一半在大根堆里，所有数中较大的一半在小根堆里 
  - 而且 大根堆的顶部 和 小根堆的顶部 一定能够算出 【中位数】
  
[315. 计算右侧小于当前元素的个数]
- 解法与 逆序对问题 求解方法 相同

[324. 摆动排序 II]
- O(N) O(1)
- TopK（快排） + 完美洗牌问题（20节第3题）
  - 如果是偶数，完美洗牌 + reverse（L1 在前）
  - 如果是奇数，那么 0 位置单独拿出来，然后剩余位置完美洗牌（R1放前）
  
[340 至多包含K个字符的最长子串]
- 双指针滑动窗口（种类具有单调性） + 哈希Map (map.size 表示当前 滑动窗口内的种类数量)


[341]
- 笨法子： 加入的时候 撸平 一个一个给你
- 解法： 准备一个栈，栈中记录在【每一个层次】中的位置
- DFS


### 高频题困难题集合
[4. 寻找两个正序数组的中位数] （好题，模型【在两个都有序的数组中找整体第K小的数， 可以做到 O(log(Min{M, N}))】）
- 原题： https://leetcode-cn.com/problems/median-of-two-sorted-arrays/
- 进阶题： 在两个都有序的数组中找整体第K小的数， 可以做到 O(log(Min{M, N}))
    - 关于时间复杂度 -> 因为是拿 等长的两段数组做二分，所以 一定是会以 短数组的长度为主， 所以使 min{M, N}
- 分阶段讲解：分成两个小问题
  - （1）【第一阶段】给定两个等长的有序数组，第中间小的数字？ -> O（log N）  （注意，编程时因为代码有很多共性，分析出第一个之后，后面只需要复制粘贴即可，注意规律）
      - 有序又是等长的，他俩相加的元素个数一定是偶数
      - 递归 （做题时举 奇数 和 偶数 的例子来做）
        - 举例： N为偶数时的情况，arr1[1, 2, 3, 4];   arr2[1', 2', 3' , 4']， 求整体第四小
        - 判断 2 与 2' 的关系， 如果 2 == 2'，则他俩之一为 第四小（上中位数）
          - 对于 2 > 2'分析，反之亦然：
          - 可以排除 3,4不是第四小，并且可以排除 1',2'不是第四小
          - 剩下 1,2,3',4' 这四个数可能是第四小。 那么 arr1[1,2] arr2[3', 4']， 求整体的第2小（依然是上中位数）
          - 于是乎 就递归下去了
          - base case: 当两个数组 只有一个数的时候，取第1小（上中位数），此时直接 Math.min()就可以了
        - 奇数情况下： N = 5
          - 3 == 3‘, 第五小就在这两个之中(任意一个)
          - 要求第5小，此时 arr1[1,2] 和 arr2[3',4',5']
          - 此时，不等长了，无法递归了吗？ 如何解决？ 手动淘汰一个  
            - 单独验证 3'是否有效，成立就是3'，否则 （3' > 2 ? 3’就是第五小 : 递归（1,2; 4',5'））
  - （2）【第二阶段】给定两个不等长但是都有序数组， 怎么求整体第K小的数字？ -> O(log(Min{M, N}))
    - 分以下三种情况
    - 【1】1<= k <= min{M, N}
      - ==> arr1 与 arr2 取等长的部分（K的长度），直接调用 【一阶段函数】
    - 【2】max{M,N} < k <= 整体长度 （特别注意，这里有一个很重要的错误点！！！ 不然会出错）
      - 以 长数组17个，短数组10个举例，求整体23个
      - 长数组 1 -> 12 都不可能 （i + 10 < 23）
      - 短数组 1 -> 5 都不可能 （i + 17 < 23）
      - 那么最终 长短数组都剩下 5 个， （求剩余整体的第5小，对吗？） 不对！！ 12 + 5 + 5 == 22， 错的！
      - 怎么办呢？ 手动淘汰 长（13） 短（6） ==》 不是这两个的话 17 + 2 + 【4】 = 23，这次是对的了
      - 边界时也是对的，比如求 27个，淘汰阶段就会返回值    
  - 【3】min{M,N} < K <= max{M,N} (大于短数组长度，小于等于长数组长度)
    - 长数组某些位置不可能，短数组所有位置全部可能
    - 比如 找寻15th的数
      - arr1剩余 11 个数字，  arr2 剩余10个数字  ==》 不等长，手动淘汰一个 （手动看一下，arr1的第5个）
      - 此时，剩余数字中的 【1阶段】第10小中位数，  ==》 10 + 5 == 15
- 别忘了，主函数里 要分情况讨论 nums1.length==0的情况，
    - 【错误点】此时，注意下标换算的问题 对于偶数而言，size/2 得到的是下中位数的下标； 
    - (s1 + e1) / 2 以及 (s1 + (e1 - s1) / 2) 得到的是 上中位数的坐标（长度为偶数时）
    - （奇数时，得到的都是 中位数的下标，直接获取即可）
  
[10. 正则表达式匹配]
  - 暴力递归入手 -> 动态规划
  - 什么模型？ 样本对应模型（两个字符串的匹配 -> 样本对应模型）
  - dp[i][j]含义 -> str[i..] 能不能被 exp[i...] 配出来
  - 暴力递归
    - str 来到 si 位置， exp来到 ei位置
    - 如何划分？ 
      - （不以ei的位置来划分，而是）以 ei 的下一个 位置是不是 ‘*’ 来划分
        - 【情况一】 如果 ei + 1 位置不是'*'，表示 si 与 ei 位置必须要对上
          - 也就是说 
            - 【1】 str[si] == exp[ei]
            - 【2】 exp[ei] = '.'
          - 如果没有对上，直接返回false
          - 如果对上了， 继续递归 f(si + 1, ei + 1);
        - 【情况二】 ei + 1 位置 是 ‘*’ （该情况最麻烦）
          - 要尝试每一个分支，有一个通就true， 否则false
    - 这个方法下，可以使用记忆化搜索 -> 但是注意 boolean结果的记忆化搜索 要使用整型
      - 因为 需要识别当前值是否算过
      - 所以 设定0表示没算， 1 表示 之前算过是true， -1表示 之前算过是false、
      - 所以 if (dp[i][j] != 0) 直接拿数据
  - 转动态规划
    - 主要关注斜率优化
    - 何时能够优化？ 当 str[i] == str[i + 1]时，可以进行斜率优化。 
  
[149. 直线上最多的点数]
- 大流程：
  - 假设有 a,b,c,d,e 五个点
  - 收集 经过a到其余点的斜率，统计次数在一个map里面 -> 求出a 的最大值
  - 对于 b,c,d,e 其余点做相同操作  =》 最终求出那个点最大的【斜率经过的点数】就可以
  - 但是注意一个事情，每个点只需要与其后续的剩余点进行斜率计算就可以。因为如果中间有答案，肯定在前面的点就出现了
- 考虑几种情况
  - 不同点 + 有斜率
  - （共点）相同位置的点
  - 共横线
  - 共竖线
  - 最终求得就是 （最大值 + 共点数量）
- 怎么表示斜率？
  - 不能用 double， 精度问题会求错
  - 那怎么表示斜率呢？ 用分数表示斜率
    - 【第一种方法】 =》 使用 【字符串的方式】 来表示 【最精简的分数】，就会很安全
    - 比如， 1/3 -> “1_3”
    - 【第二种方法】 =》 使用 一张map<Integer, map<Integer, Integer>> Key表示分子， Value还是一张map表 <分母， 该分数得到的点数>
- 这道题到这里变成什么了？
  - 给定一个数x，y， 变成最精简的分数  ==》求最大公约数
  
[41. 缺失的第一个正数](topInterviewHardQuestions/FirstMissingPositive.java)
- 具体看代码
```
核心： 【1】固定位置 arr[0]=1; arr[1]=2，这样规定我们要实现的数组形式
        【2】由于存在满足和不满足的部分，所以 两端双指针 + 指针模拟 有效区与无效区（注意清晰L， R对应的含义，很重要）
L ,R 双端双指针
[0, L]为有效区，每一个位置 i 上的元素为 i + 1 (实现过程中，将L设置为[0, L)容易coding)
[R, N - 1]为无效区（垃圾区） -> 排除掉的已经不可能是有效区的元素
此处，R还有一个意义，就是 R 代表 目前最大期望的正整数 (因为 R-1 位置为最大期望，对应值就是R)
由此，进行分类情况讨论， 元素留在有序区 || 进入垃圾区
```
- 【错题，错误点】（1）注意 while循环的结束标志 （2）最终返回时，R代表有效区的最后一个元素值，所以 还要+1
- 【重点】分情况讨论
  - 元素进入有效区（一种情况）
  - 元素进入无效区（难点，三种情况）
  - 元素去到对应位置进行交换（剩余的一种情况）
  
[42. 接雨水](topInterviewHardQuestions/Trap.java)
- 首先第一个想法： 计算每个柱子上能够存储的水量 （核心就是 知道 柱子两侧最大值的较小值） =》 加和 就能得到 最终的接雨水数量
- 首先，两端不需要求 -> 两端存不出水
- 【核心】 双端双指针 + 左右侧最大值中的较小值比较
- 【进一步的理解】说白了，核心就是 需要知道 每一根柱子 哪一侧的最大值较小，那么那个较小值（与柱子的高度之差）就是 在这个柱子上所能够 承接的 水量。
  - 如果从高值算的话，那么 R位置 与 低值之间可能存在 很大的值，R位置盛水量会算错。 具体一点就是，！！ 高值算的话，高值那一侧最大值确定，而低值一侧max 完全不确定， 可能 >高值也可能小于高值，无法确定 柱子盛水量（无法确定两侧最大值的较小值）。
  - 但是如果是算 低值那一侧的值的话，低值一侧 max绝对确定， 而高值那一侧真实max>= 高值，所以绝对能够确定该柱子 唯一的 左右两侧的最大值的较小值 （就是左侧的低值）。
- 【总结】： 
  - 总高值那一侧算的话，无法确定 两侧最大值的较小值。
  - 但是从低值那一侧算的话，绝对 确定两侧最大值的 较小值。
- 【步骤】 就是 计算 最大值较小一侧指针的柱子，然后移动指针 + 更新该区间最大值。

[76. 最小覆盖子串]
- 经典的欠债模型
- 窗口 -> 为啥能用窗口？
  - 因为有单调性 -> str1 窗口增大， 就能够涵盖更多的或者不变的 str2 的字符数量。 这就是单调性
  - 直白一点，str1 窗口变大了， 搞定 str2 的字符个数只会变多不会变少
- 解法：  
  - 创建一张 map， 统计 str2 中 字符的数量 -> 表明目前欠的字符及其数量（随着窗口的滑动，数量会发生改变，（无效还款）还的多了会变成负数）
    - 在实现中， 因为 欠账表 的是 字符，它的 ASCII码就是 0-255，所以一个256的int数组就可以搞定了
  - 一个变量 all， 统计有效还款 的剩余 （无效还款时 all不改变）【这个all 与 map 联系很紧密】
```
欠债模型 ：
滑动窗口内部就是 还债的字符 -> R++ 还债，map[str1[R]]--; L++ 还了的收回来，map[str1[L]]++ -> 每次变动后， 注意 all的取值 是否要发生改变（有效欠账就变，无效就不变）注意判断有效欠账（++）和还账（--）的条件

同端双指针
int[256] 模拟 map -> 欠账表
ASCII 码 对应 0-255
一个变量all 与 这个 map 联系很紧密。一起变动
```
- 突然发现，乱序的字符串相关题目经常要用到map。 不管是 定位 / 计数

[84. 柱状图中最大的矩形 【错题】](TopInterviewClassicQuestions/LargestRectangleArea.java)
- 单调栈经典问题
  - 注意 相同高度的处理， 相同高度也弹栈 -> 以最右侧的该高度的柱子会得到正确结果
- 单调栈问题 习惯用 数组来模拟栈， 常数时间快很多
- 【错题！！！】 一定要注意 【第一阶段中】 while() 中 比较的语句  heights[stack[size - 1]] >= heights[i] ,而不是 stack[size - 1] >= height[i]
  - 弹出的只是下标
  - 比较的时候 是要映射到 数组的值
  - 单调栈存下标， 单调是 下标映射成值 之后呈单调性
  
[124. 二叉树中的最大路径和]
-  【错误点！！】 Info中包含任何数值的话，都返回null(之前只以为 max,min不行，现在看来 路径和也不可以，所以int这种数值类型都不行，会带错答案)。  有boolean类型的话， 可以选择性返回new Info。
- 【错误点II】 有些时候，逻辑对了，结果错了 -> 想一下，是不是会是 process 最后return new Info() 时候，传的实参与参数 没对上！！
- 第一问： 单纯的求 二叉树的最大路径和
- 第二问： 把 最大路径和 的路径打印出来

[127. 单词接龙]
- 【核心】两端搜索 + BFS （每次从较小端(窄的那一侧)开始BFS）
- 先要找 邻居， 怎么找？
  - 生成一张map， Key 是任意一个字符串（比如 bbkf）， value 是 所有 bbkf的邻居
- 当有了 这张邻居map表后，做 宽度优先遍历 ->　每一层都做ＢＦＳ，最终　遍历的层数　就是　接龙的次数。
  -　对于　建立邻居表的优化方法
    - 暴力方法就是 从 List里面 每次取一个 单词，然后跟curWord 顺序遍历，如果只有一个不一样的 那么就作为curWord的邻居。
    - 优化方法， 因为本题给定数据是这样的-> word.length小， List很大 -> 对于curWord（假设abc），我们对每个位置上的 字母 进行变换（题目只给定 26个小写字母，这就使得 每个位置 只需要变换 25次。）
    - （续优化方法）在这之前，将list中的单词 全部放进 HashSet中，这样 每次单词将小写字母变换25次的时候，去Set中看有没有这个单词就可以了
-　更好的改进方法？ （没有再用队列了，使用了两个 Set 结构 完成了 宽度优先遍历， 有一个额外Set visit， 防止遍历重复的元素）
  -　两头　来　往中间　走　　－＞　永远只选择　窄的那一侧　展开　－＞　优化常数时间
  -　看　两端什么时候撞上 （每次从较小端开始BFS）
- 宽度优先遍历 设置 一个Set 一个 Queue
  - Set 是给 Queue 专用的
  - 因为要防止 重复元素 的遍历
  - 怎么做的呢？ 进过 Queue 的元素 都放到 Set 中去。 这样下次 在添加元素的时候，如果已经在SET中，那么就不进队列了，从而就不会重复遍历了（防止跑不完了）。
- 时间复杂度？
  - N 个单词， 每个单词 K个
  - 最差情况， 数组中N个字符串都要找到， 连成一条线， 以单词为单位 就是 O（N）   BFS -> O(N)
  - 对与总体，对于每个单词（K长度）， 每个单词的一个位置要尝试25种可能，所以是O（25*K）。 然后，每变出来的一种可能，查看它存在不存在又是O（K）
    - 所以每个单词 尝试所有可能性，每种可能性在不在map中  == 》 O(k^2 * 25)
  - 而一共有N个单词（一共会遇到多少个单词进你的宽度优先的数量）  -> 总时间复杂度就是 O（N * K^2 * 25）


### TopInterView valuable questions （中等难度的比较不错的题）
[128 最长连续序列](TopInterviewClassicQuestions/Code128_LongestConsecutiveSeq.java)
- 【难点】如何只使用一张哈希表搞出来
- 解法： 跟设计一个直播系统。数据流不是按顺序来，要求能够按顺序打印，思路相似
- 基本思路： 哈希表2张
  - 连续区间头表
  - 连续区间尾表
  
[15 三数之和]
- 基于 有序数组的二和问题  -> 双指针
  - 去重问题
    - （1）过滤去重
    - （2）流程上 通过设计 让它就没有重复值 ！
      - 收集的时候，如果 收集的位置的值 与 前面位置的值一样，那么就不收集
- 至此， 【第一阶段 - 有序数组二元组问题】f(arr, L, R, K) 作为基本函数，用于求出 arr中，[L, R]区间下，满足K的不同二元组问题
- 对于三元组问题，假设 i 位置的值是5，那么求 5 后面的数组中 二元组K值为-5的二元组，加上当前的i位置，就配成了 三数之和为0的三元组
  - 此外，在i位置跳跃过程中，如果 arr[i] == arr[i- 1]，那么说明该元素已经被检查过了， 直接跳过
  - 【注意】： 对于每一个位置i，只需要检查它后面的 位置中 的二元组。从而也就出现了 连续的查询范围区间
- 有个小私心，从右往左生成三元组，二元组是找左侧 ==》 这样插入 list末尾位置会代价低（插头代价高）

[134. 加油站] 良好出发点问题
- 解决下列问题： 返回一个boolean数组，表示每个点是否可以满足条件 ->　时间复杂度O（N），额外空间复杂度O(1)
- Step1: 首先转化成 纯能数组 (gas[i] - cost[i])
  - 于是，就将 问题转化为 =》哪个点从自己出发到回到自己以前，纯能累加和不会跑到0以下，它就是良好出发点
- 使用 gas数组 作为纯能值数组，然后结束运算后，恢复原来的值
- 找到纯能数组中 第一个为正数的点（因为如果第一个点为负数，那么它一定不是良好出发点）
- 有一个概念叫做 【连通区】 【a, b） + int rest (到尾部的剩余油量) + int need （接入连通区的头部需要的代价）
- 先说一下针对 【LC原题】(只针对无良好出发点 || 只有一个良好出发点) 的解法，其实很简单，通过数学推导可知：
  - 能够得出结论：从 x,y 之间的任何一个加油站出发，都无法到达加油站 y 的下一个加油站
```
我们首先检查第 0 个加油站，
并试图判断能否环绕一周；
如果不能，就从第一个无法到达的加油站开始继续检查。
```
- 官方题解里面有一个很好的提示 ！！！ 【环形数组取下标】
   - 关于 【环形数组】 的下标 -> 想想钟表
   - 步骤： 直接加上要求的位置， 然后 取模 ， 就可得到对应原数组的位置
  
[38 外观数列](TopInterviewClassicQuestions/CountAndSay.java)
- 多背，多看，记住思路和注意点

[46 全排列]
- DFS + 回溯 + 原数组交换swap！

[50. Pow(x, n)]
- 先搞定基本的功能函数 （适用于 n 为非负数次幂（n >= 0）， 然后 底数 int, double 都可以）

[69. x的平方根]
- 解法： 使用二分法！！
- 寻找 a*a <= N 的 最右位置！
- 为了防止溢出 - 可以使用 long 类型 作为中间值
- 延伸题： 给一个 double 类型的数字 -> 给一个数字K，让你返回 开根号 后的小数点后的K位
  - 解法： 还是二分法
  - 先使用 二分法 求出 【整数部分】
  - 然后 根据小数部分区间 [0.0000, 0.9999] （假设K=4），继续二分。 只需要注意 选中二分的值之后，计算的是 【整数部分】+ mid小数部分 的平方 <= double类型的target

[56. 合并区间](TopInterviewClassicQuestions/MergeIntervals.java)
- 不用使用并查集
- 解法：
  - 首先 按照 开始时间排个序（创建 比较器， 二维谁在前谁在后无所谓）
  - 看 新的元素的 start 是否比当前区间的 end 小，如果是的话就看是否能够扩充区间； 否则的话，就是新的开头
- int s, int e 记录当前区间的开头和结尾，如果 有新的区间要产生了，那就将 旧的s,e存入，然后 s,e更新为新的区间的首尾
- Arrays.copyOf(intervals, size);  (int[] original, int newLength) -> 返回新的数组

[62. 不同路径的数量]
- 排列组合问题 + 经典 gcd （防止溢出）
- 计算组合数 C(2, 3)
- 假设有一个 6 * 5的矩阵（宽*高）
  - 那么可以确定 （因为左上角到右下角 && 机器人只能往右走或者往下走） =》 一定会往右走 5步，往下走4步
  - 那么 我们可以知道 总共一共会走 9步，其中 4步往下，5步往右  ==》 排列组合问题
  

[73. 矩阵置零]
- 难点在于怎么使用 O（1）的额外空间复杂度 实现
- 两个变量： 一个变量记录0行是否变0 + 一个变量记录0列是否变0 + 其余是遍历中间部分时，如果是0，就将对应的0行0列对应位置变成0
- 进一步 -> 一个变量： 一个变量记录0列是否变0， 然后 使用m[0][0]位置（两个变量时该位置没有用做记录中间部分）记录0行得置0情况。


[79. 单词搜索 (好题 DFS)](TopInterviewClassicQuestions/WordSearch.java)
- DFS + 不走回头路技巧（结合 回溯） 【这个还挺重要的，不难但是之前没想到】
  - 什么时候会走回头路呢？ 有些题目中，探索路径的过程中 要求每个点 可以上下左右的走，并且没有限制的四个方向走
  - 此时，存在走已经走过的路（当前DFS这条路径） 上的点 问题
  - 解决方案： 
    - 走过的点标记为 0（对于char[][]）（对于别的类型数组也可以，但反正是要 一个与题目无关的值，来表示该点【已经走过】，dfs遇到时则直接返回）
    - 接着，结合回溯，三步走。
      - 1. 将 当前点 设置为 0
      - 2. dfs 到下一个位置（或 for循环 多个位置）
      - 3. 该点后面所有路线探索完毕后，函数要返回之前。 将该点值（tmp）恢复回来。从而完全无影响。（上一节点走别的分支时候无影响）

[88. 合并两个有序数组] （merge 操作练习）
- （很简单，但是一开始不会）本质： merge 操作
- 【核心】 从后往前 merge
- 把思路打开： 两个方向都可以 merge
  - （1）从前往后merge ， 谁小放谁
  - （2）从后往前merge， 谁大放谁 【本题使用这个】
- merge 就是 三段论 
  - 首先全是 使用 while 循环
  - 1. 两个都有数，比较放
  - 2. 如果只有1有数了，那么1顺下去
  - 3. 如果只有2有数了，那么2顺下去
  

[200. 岛屿数量]
- 两种解法
  - 【1】感染模型 - 递归（感染的ASCII码全变0）
    - 已经是最优解了，难点在于复杂度分析
      - 首先每个点会遍历一遍，其次在感染过程中，每个点最多会被它的上下左右 各自调用一次（如果被感染之后，其他方向来了直接返回），所以最终就是每个点最多调用五次。
      - 最终时间复杂度就是 O（M * N）
  - 【2】并查集
    - 【核心】每个点与它的 左和上 进行连通即可 （只需要每个点的左上， 整张图就会连通起来的）
    - 【难点】对于二维表的 并查集 怎么做？ 如何把二维表中的每个点 转化为 初始化时的集合
      - （1）low方法 -> 创建空dot对象（m[i][j] == '1', 那么 board[i][j] = new Dot(), 并将其add进List），通过 dot地址 的不同值 来区分不同的集合。（constructor传入 list<Dot>即可）
        - 这种方法由于， Dot对象地址的不确定性，所以要使用 HashMap实现的 并查集 来做（才可以存 sizeMap和 parentMap）
      - （2）好方法 -> 将 二维数组 (i, j) 的下标 换算成 一维的下标  （flatten）    （当M*N超过整数范围时，可以内置一个二维数组来作为 parentMap,然后类型是 Posititon(包含 行号+列号 属性)）
        - 一、如何换算
          - 比如， 4*6的矩阵 (0,5) -> 5；   (1,5) -> 1*6+5=11
          - 【核心】所以公式是什么？ (i, j)  => i * M（列数） + j;  M为 列数
          - 从而，二维数组中 每一个独立的位置，它的下标是唯一的
        - 只有当 m[i][j]=='1'时， 才会 在 parentMap[] 和 sizeMap[]中 初始化这个集合
    - 【错误点】进行 Union 操作时， 注意 最后如果成功合并的话，记得将 int sets--；
    
[130. 被围绕的区域]
- 也是 感染过程 的相关题目
  - 感染模型就是 -> 将 01组成的 矩阵 中， 从某一个点出发 将所有连通的1全部变成2
    - 递归
    - 是 1 就改
    - 不是 1 就直接返回  （0/2）
    - 所以不会有回头路的问题
- 解法： 先看看四周边框，哪一个是0，就将他感染进去，同一改成Y字符
  - 然后没有被Y感染的，就全部都是 1（没有变Y的0直接改成X）
- 时间复杂度 O（N * M）   （每个节点遍历 感染模型 ==》Ｏ（ｍ　*　ｎ），　每个节点会被访问五次（１（遍历）　+　４（上下左右四个方向到该点递归）））
[101. 对称二叉树]
- 【难点】迭代方式求
  - (1)queue 中不进null
  - （2）queue中进 null -> 弹出时检查，这样写的话 代码会简洁一点

[103. 二叉树的锯齿形层序遍历]
- 不要使用一个 list 层序遍历完了之后 在reverse =》 很low，不通过
- 解法： 使用双端队列
  - 注意： add == addLast
  - deque中始终 维持 层序遍历（每一层 从左到右的节点顺序 的节点摆放）  =》方向问题 从不同的首尾出 来解决（注意 队首队尾出时，为维持deque内节点的顺序，左右孩子进队列的顺序和进入口 正好是反着的）

[105. 从前序与中序遍历序列构造二叉树]
- 解法：递归
  - 分解子问题， 找到 左子树，右子树 对应的 数组区间 后，创建当前树的头，然后递归 左子树右子树

[131. 分割回文串]
- 解法： DP 预处理 + 回溯（一个变化参数的回溯递归）
- 预处理结构 -> 又一个动态规划 ==》 范围尝试模型 l,r
### TopInterview 错题集
  
[34. 在排序数组中查找元素的第一个和最后一个位置](TopInterviewClassicQuestions/SearchRange.java)
- 【错题】思路很简单，但是写代码时候出现了很多小错误，反省 记录 回顾

[33. 搜索旋转排序数组](TopInterviewClassicQuestions/SearchInRotateArr.java)
- 【高频 + 错题】漏掉了 L == MID 的情况，此时 必须也只能 L++
- 当 arr[L]==arr[M]==arr[R]时，不能二分； 否则只要三者不相同，一定可以二分
  - 当 arr[L] == arr[M] != arr[R] 时， 比较 arr[M] 与 arr[R]的关系

[29 两数相除](TopInterviewClassicQuestions/BitsDivide.java)
- 【难题 + 错题】
- 特别注意： 其他题目也是：注意 所有有关 位运算的计算 都必须要加上括号 （位运算优先非常低）

[24. 两两交换链表中的节点](TopInterviewClassicQuestions/ReversePairs.java)
- 【打错误点，错题，看了很久没找出来问题！！】 与反转n个链表那道题都要一起注意！！！
- 在 reverseList 中，那个 while循环，不能写 while (cur != null)！
-  因为 这样的话，不会 按照 [start, end] 的范围逆转链表，反而会把整个链表全部反转过来！ 最后死循环
- PS: 逆转涉及到换头，所以dummy

[54. 螺旋矩阵](TopInterviewClassicQuestions/SpiralOrder.java):
- 各种分情况讨论就OK
- 注意 单圈下分为四种情况讨论
  - 只有一个点
  - 只有一列
  - 只有一行
  - 多列多行
    - 其中多列多行分为 上右下左 依次输出即可
- 主函数 只需要确定 (r1,c1) (r2,c2) 然后每次 (r1++,c1++) (r2--,c2--) 就可以不断 更新到新的圈（矩形框）

[69. x 的平方根](TopInterviewClassicQuestions/mySqrt.java)
- 二分法
- 【错误点】 二分法中 进行 比较时 mid * mid 会溢出 int 范围。 两种解决方案
  - （1）所有类型变成 long, 注意 赋值 时 的 统一
  -  (2) 保留 int 类型， 但是 在 mid * mid 的比较条件中 将其 转为long 类型，从而可以比较
  
[75. 颜色分类](TopInterviewClassicQuestions/SortColors.java)
- 荷兰国旗问题
- 【错题】slow + wrong

[78. 子集] （相当于生成 所有的 子序列 问题）
- 递归 + 回溯
- 每个位置要/不要 + 剩余部分子序列 -》 List<>() path
- 【错误点】 base case 结尾一定要有 return;  !!!! 每次写完必须检查下！！

[116. 填充每个节点的下一个右侧节点指针]
- 普通方法 -> BFS 按层遍历 + 使用队列
- 【最优解】 -> 额外空间复杂度 O（1）做法 -> 不使用队列 -> 复用二叉树节点的next指针，自己制作队列（单向链表。  队尾进队首出）
  - 但是 本质上 还是使用队列
  - 但是！！！ 没有使用系统提供的队列，我们自己 设计队列 （只增加 head, tail 指针 + int size）
  - 其余的 使用原来的 二叉树的节点直接进行连接 （从而额外空间复杂度就变成了 O（1））
    - 比如 offer(Node cur)操作, 直接 tail.next = cur 这样子，从而不会增加节点数量，没有产生其他的空间
- 【重点】为什么这道题可以这样做呢？？？？
  - 因为 这道题给定的 二叉树节点 自带 next 指针。 从而满足了queue的 单向链表要求。  其他的二叉树遍历，没有next指针，所以要用系统提供的，会内部封装成带有next指针的节点。
- 错误点
```
【错误点】 poll这里有个细节要注意， 弹出节点的next指针一定要 重新置null
因为 这个跟 之前链表删除不同，head=head.next了，原来head对应节点并不会被删除，因为有ans 或者原来对应的树上节点 引用。 所以因为还有其他引用，将该节点从 链表上取下来的时候要讲next指针 置 null。 （这一点不同于 使用linkedlist容器，因为那个会进行二次封装，next指针不会用到。我们复用了，如果不还原的话，每一层最后的指针都会还有值，不是指向null）。总之，节点弹出队列时，应该与进入队列时 无差异！！！。
```  

[118. 杨辉三角I II](TopInterviewClassicQuestions/YangHuiSanJiao.java)
- 具体看代码注释
- 【核心】中间每个值 依赖于 上和左上
- 【错误点】注意 0行 不是首尾+1的处理， [1,...]才是这样的处理 + [1,...]的中间位置 才可以依赖上面的位置
- 所以 最后的for循环 外层循环要从1开始。 0行 提前做好。 （搞明白 i 行的 长度 是 i + 1）


[125. 验证回文串](TopInterviewClassicQuestions/IsPalindrome.java)
- 【很多错误点】具体看代码
```
整体字符串是否是 回文串 -> 首尾双指针就可以
【注意点】包含数字和字母， 其中 对于字母，大小写忽略
Manacher 是关于字符串匹配算法的，找到 str 中的 最长回文子串（本质是求出每个位置对应的回文子串的长度）
【错误点】（1）没有注意到可以忽略大小写
【错误点】（2）没有注意到， 回文串随意，但是只考虑 字母+数字
【核心】函数设计能力  ==》因为每次都对 L,R两个位置的 字符检验，检验成功之后还要再次分清楚 字母 和 数字 ==》 所以 专门设计 isNum isLetter!!! 不然要写很多繁琐代码
```